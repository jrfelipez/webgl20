<!DOCTYPE HTML>
<html>
  <head>
    <style>
      html, body {
        width:  100%;
        height: 100%;
        margin: 0px;
        border: 0;
        overflow: hidden; /* Deshabilita las barras de desplazamiento */
        display: block;   /* Sin contenido flotantes a los lados */
      }
      #gui {
        position : absolute; /* Posición absoluta con relación a la ventana gráfica */
        top : 0;
        left : 0;
      }      
    </style>
    <title>Iluminación de Archivo .OBJ .MTL (genera las normales) en WebGL 2.0</title>
    <meta http-equiv="content-type" content="text/html;charset=utf-8">
  </head>
  <body>
    <form id="gui" name="entrada">
      <table>
        <tr>
          <td><font color= #CCF>Objeto:</font></td>
          <td><select id="objeto">
                <option value="0">Cubo</option>
                <option value="1">Avion</option>
                <option value="2">Al Capone</option>
                <option value="3">Coche</option>
                <option value="4">Rosa</option>
              </select></td>
        </tr>
      </table>
    </form>              
    <canvas id="webglcanvas" style="border: none;" width="500" height="500"></canvas>
    <!--
      /***************************************************************************/
      /* Paso 1: Se definen los códigos shaders.                                 */
      /***************************************************************************/
    -->
    <script id="vs" type="vertex">
      #version 300 es
      precision mediump float;
      uniform mat4 uMatrizProyeccion;
      uniform mat4 uMatrizVista;
      uniform mat4 uMatrizModelo;

      layout(location = 0) in vec3 aVertices;
      layout(location = 1) in vec3 aNormales;

      out vec3 vNormales;
      out vec3 vVertices;

      void main() {

        // En coordenadas de la camara (la normal)
        vNormales = mat3(uMatrizVista) * mat3(uMatrizModelo) * normalize(aNormales);

        // En coordenadas de la camara (el vertice)
        vec4 vertices = uMatrizVista * uMatrizModelo * vec4(aVertices, 1.0);

        // vertices(x,y,z)
        vVertices = vertices.xyz / vertices.w;

        // P' = Proy * Vista * Modelo * P
        gl_Position = uMatrizProyeccion * vertices;
      }
    </script>

    <script id="fs" type="fragment">
      #version 300 es
      precision highp float;
      
      uniform vec3 uPosicionVista;
      uniform vec3 uPosicionLuz;
      uniform vec3 u_Ia;
      uniform vec3 u_Id;
      uniform vec3 u_Is;
      uniform vec3 u_ka;
      uniform vec3 u_kd;
      uniform vec3 u_ks;
      uniform float u_brillo;

      // Estas variables son enviadas del shader de vértice.
      in vec3 vNormales;
      in vec3 vVertices;

      out vec4 color;
      void main() {

        // Vectores
        vec3 N = normalize(vNormales);
        vec3 L = normalize(uPosicionLuz - vVertices);
        vec3 V = normalize(uPosicionVista - vVertices); // posicion - vista
        vec3 H = normalize(L + V);

        // Factores de iluminacion	
        float NL = max(0.0, dot(N, L));
        float NH = max(0.0, dot(N, H));

        // Calcula la luz ambiente
        vec3 luzAmbiente = u_ka * u_Ia;

        // Calcula la luz difusa
        vec3 luzDifusa = u_kd * u_Id * NL;

        // Calcula la luz especular
        vec3 luzEspecular = u_ks * u_Is * pow(NH, u_brillo);

        // Modelo de Phong
        vec3 rgb = luzAmbiente + luzDifusa + luzEspecular;

        // La salida gl_FragColor es un vec4 que contiene el pixel color de este fragmento
        color = vec4(rgb, 1.0);

      }
    </script>

    <script>
      "use strict";

      /* Variables globales */
      var canvas;
      var programaID;
      var gl;
      var objeto;

      /* Variables Uniformes */
      var uMatrizProyeccion;
      var uMatrizVista;
      var uMatrizModelo;
      var uPosicionVista;
      var uPosicionLuz;
      var u_Ia;
      var u_Id;
      var u_Is;
      var u_ka;
      var u_kd;
      var u_ks;
      var u_brillo;

      /* Matrices */
      var MatrizProyeccion = new Array(16);
      var MatrizVista = new Array(16);
      var MatrizModelo = new Array(16);

      /* Ubicación de la vista */
      var posicionVista = [0, 0, 0];

      /* Ubicación de la luz */
      var posicionLuz = [3, 3, -2];

      /* Para la interacción */
      var rotX = 0;
      var rotY = 0;
      var antX;
      var antY;
      var boton_izq_presionado = false;

      /***************************************************************************/
      /* Paso 2: Se crean, compilan y enlazan los programas Shader               */
      /***************************************************************************/
      function compilaEnlazaLosShaders() {

        /* Se compila el shader de vertice */
        var shaderDeVertice = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(shaderDeVertice, document.getElementById("vs").text.trim());
        gl.compileShader(shaderDeVertice);
        if (!gl.getShaderParameter(shaderDeVertice, gl.COMPILE_STATUS)) {
            console.error(gl.getShaderInfoLog(shaderDeVertice));
        }

        /* Se compila el shader de fragmento */
        var shaderDeFragmento = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(shaderDeFragmento, document.getElementById("fs").text.trim());
        gl.compileShader(shaderDeFragmento);
        if (!gl.getShaderParameter(shaderDeFragmento, gl.COMPILE_STATUS)) {
            console.error(gl.getShaderInfoLog(shaderDeFragmento));
        }

        /* Se enlaza ambos shader */
        programaID = gl.createProgram();
        gl.attachShader(programaID, shaderDeVertice); 
        gl.attachShader(programaID, shaderDeFragmento);
        gl.linkProgram(programaID);
        if (!gl.getProgramParameter(programaID, gl.LINK_STATUS)) {
            console.error(gl.getProgramInfoLog(programaID));
        }

        /* Se instala el programa de shaders para utilizarlo */
        gl.useProgram(programaID);
      }

      /***************************************************************************/
      /* La Clase Vector3                                                        */
      /***************************************************************************/

      class Vector3 {

        /**
         * Construye un nuevo Vector.
         */
        constructor(x, y, z) {
          this.x = x;
          this.y = y;
          this.z = z;
        }

        /**
         *                   u = Suma de vectores
         *  u = v1 + v2     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         *                   u = (v1.x + v2.x, v1.y + v2.y, v1.z + v2.z)
         */
        mas(v2) {
          return (new Vector3(this.x + v2.x, this.y + v2.y, this.z + v2.z));
        }

        /**
         *                   u = Resta de vectores
         *  u = v1 - v2     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         *                   u = (v1.x - v2.x, v1.y - v2.y, v1.z - v2.z)
         */
        menos(v2) {
          return (new Vector3(this.x - v2.x, this.y - v2.y, this.z - v2.z));
        }

        /**
         *                      u x v = Producto vectorial o producto cruz
         * u = (u.x, u.y, u.z) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         * v = (v.x, v.y, v.z)  u x v = (u.y * v.z - u.z * v.y,   
         *                               u.z * v.x - u.x * v.z,
         *                               u.x * v.y - u.y * v.x)                  
         */
        producto_vectorial(v2) {
          var r = new Vector3(0,0,0);
          r.x = (this.y * v2.z) - (this.z * v2.y);
          r.y = (this.z * v2.x) - (this.x * v2.z);
          r.z = (this.x * v2.y) - (this.y * v2.x);
          return r;
        }

        /**
         *                      u . v = Producto escalar o producto punto
         * u = (u.x, u.y, u.z) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         * v = (v.x, v.y, v.z)  u . v = u.x v.x + u.y v.y + u.z v.z
         *                                          
         */
        producto_escalar(v2) {
          return (this.x * v2.x) + (this.y * v2.y) + (this.z * v2.z);
        }

        /**
         *                     |v| = Longitud de un vector o magnitud
         * v = (x, y, z)    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         *                     |v| = raiz_cuadrada (x^2 + y^2 + z^2) 
         *                                          
         */
        longitud() {
          return (Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z));
        }

        /**
         *        v            u = Vector unitario o de longitud 1
         *  u  = ---        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         *       |v|           u = Vector normalizado
         *                     
         */
        normaliza() {
          var l = this.longitud();
          if (l > 0 ) {
            this.x = this.x / l;
            this.y = this.y / l;
            this.z = this.z / l;
          }
        }

        /**
         *    3 
         *     ^
         *     |
         *   v | 
         *     |
         *    1 -------- > 2
         *          u
         */
        normal(v1, v2, v3) {
          var u = new Vector3(0,0,0); // vector u
          var v = new Vector3(0,0,0); // vector v
          var n = new Vector3(0,0,0); // vector n

          /* Calcula los vectores u y v */
          u = v2.menos(v1);
          v = v3.menos(v1);

          /* n = u x v */
          n = u.producto_vectorial(v);
    
          /* Normaliza */
          n.normaliza();
    
          return n;
        }

        toString() {
          return "Vector3 [x=" + this.x + ", y=" + this.y + ", z=" + this.z + "] <br>";
        }
      }

      /***************************************************************************/
      /* Transformación de las Matrices                                          */
      /***************************************************************************/

      /* Convierte de grados a radianes */
      function toRadians(grados) {
        return grados * Math.PI / 180;
      };

      /* Matriz Identidad */
      function identidad(r) {
        r[0] = 1; r[4] = 0; r[ 8] = 0; r[12] = 0;
        r[1] = 0; r[5] = 1; r[ 9] = 0; r[13] = 0;
        r[2] = 0; r[6] = 0; r[10] = 1; r[14] = 0;
        r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
      }

      /* Traslación - glTranslatef */
      function traslacion(matriz, tx, ty, tz) {
        var r = new Array(16);
        r[0] = 1; r[4] = 0; r[ 8] = 0; r[12] = tx;
        r[1] = 0; r[5] = 1; r[ 9] = 0; r[13] = ty;
        r[2] = 0; r[6] = 0; r[10] = 1; r[14] = tz;
        r[3] = 0; r[7] = 0; r[11] = 0; r[15] =  1;
        multiplica(matriz, matriz, r);
      }

      /* Escalación - glScalef */
      function escalacion(matriz, sx, sy, sz) { 
        var r = new Array(16);
        r[0] = sx; r[4] =  0; r[ 8] =  0; r[12] =  0;
        r[1] =  0; r[5] = sy; r[ 9] =  0; r[13] =  0;
        r[2] =  0; r[6] =  0; r[10] = sz; r[14] =  0;
        r[3] =  0; r[7] =  0; r[11] =  0; r[15] =  1;
        multiplica(matriz, matriz, r);
      }

      /* Rotación sobre X - glRotatef */
      function rotacionX(matriz, theta){
        let r = new Array(16);
        var c = Math.cos(toRadians(theta));
        var s = Math.sin(toRadians(theta));
        r[0] =  1; r[4] =  0; r[ 8] =  0; r[12] = 0;
        r[1] =  0; r[5] =  c; r[ 9] = -s; r[13] = 0;
        r[2] =  0; r[6] =  s; r[10] =  c; r[14] = 0;
        r[3] =  0; r[7] =  0; r[11] =  0; r[15] = 1;
        multiplica(matriz, matriz, r); 
      }

      /* Rotación sobre Y - glRotatef */
      function rotacionY(matriz, theta){
        let r = new Array(16);
        var c = Math.cos(toRadians(theta));
        var s = Math.sin(toRadians(theta));
        r[0] =  c; r[4] =  0; r[ 8] =  s; r[12] = 0;
        r[1] =  0; r[5] =  1; r[ 9] =  0; r[13] = 0;
        r[2] = -s; r[6] =  0; r[10] =  c; r[14] = 0;
        r[3] =  0; r[7] =  0; r[11] =  0; r[15] = 1;
        multiplica(matriz, matriz, r);
      }

      /* Rotación sobre Z - glRotatef */
      function rotacionZ(matriz, theta){
        let r = new Array(16);
        var c = Math.cos(toRadians(theta));
        var s = Math.sin(toRadians(theta));
        r[0] =  c; r[4] = -s; r[ 8] =  0; r[12] = 0;
        r[1] =  s; r[5] =  c; r[ 9] =  0; r[13] = 0;
        r[2] =  0; r[6] =  0; r[10] =  1; r[14] = 0;
        r[3] =  0; r[7] =  0; r[11] =  0; r[15] = 1;
        multiplica(matriz, matriz, r);
      }

      /* Proyección Paralela - glOrtho */
      function ortho(r, izq, der, abj, arr, cerca, lejos) {
        r[0] = 2/(der - izq); r[4] =             0; r[ 8] =                  0; r[12] =         -(der + izq)/(der - izq);
        r[1] =             0; r[5] = 2/(arr - abj); r[ 9] =                  0; r[13] =         -(arr + abj)/(arr - abj);
        r[2] =             0; r[6] =             0; r[10] = -2/(lejos - cerca); r[14] = -(lejos + cerca)/(lejos - cerca);
        r[3] =             0; r[7] =             0; r[11] =                  0; r[15] =                                1;
      }

      /* Proyección Perspectiva - glFrustum */
      function frustum(r, izq, der, abj, arr, cerca, lejos) {
        r[0] = 2*cerca/(der-izq); r[4] =                 0; r[ 8] =          (der+izq)/(der-izq); r[12] =                            0;
        r[1] =                 0; r[5] = 2*cerca/(arr-abj); r[ 9] =          (arr+abj)/(arr-abj); r[13] =                            0;
        r[2] =                 0; r[6] =                 0; r[10] = -(lejos+cerca)/(lejos-cerca); r[14] = -2*lejos*cerca/(lejos-cerca);
        r[3] =                 0; r[7] =                 0; r[11] =                           -1; r[15] =                            0;
      }

      /* Proyección Perspectiva - gluPerspective */
      function perspective(r, fovy, aspecto, cerca, lejos) {
        var ang = fovy * 0.5;
        var f = (Math.abs(Math.sin(toRadians(ang))) < 1e-8 ? 0 : 1) / Math.tan(toRadians(ang));
        r[0] = f/aspecto; r[4] = 0; r[ 8] =                                  0; r[12] =                                       0;
        r[1] =         0; r[5] = f; r[ 9] =                                  0; r[13] =                                       0;
        r[2] =         0; r[6] = 0; r[10] = -(lejos + cerca) / (lejos - cerca); r[14] =  -2.0 * lejos * cerca / (lejos - cerca);
        r[3] =         0; r[7] = 0; r[11] =                              - 1.0; r[15] =                                       0;
      }

      /* Camara - gluLookAt */
      function lookAt(r, vistaX, vistaY, vistaZ, centroX,
        centroY, centroZ, arribaX, arribaY, arribaZ) {

        var vista = new Vector3(vistaX, vistaY, vistaZ);
        var centro = new Vector3(centroX, centroY, centroZ);
        var arriba = new Vector3(arribaX, arribaY, arribaZ);
    
        /* n = vista - centro */
        var n = vista.menos(centro);

        /* u = u / || u || */
        n.normaliza();
  
        /* v = arriba */
        var v = arriba;

        /* v = v / || v || */
        //v.normaliza(); // No es necesario!

        /* u = v x n */
        var u = v.producto_vectorial(n);
  
        /* u = u / || u || */
        u.normaliza();
  
        /* Recalcula v: v = n x u */
        v = n.producto_vectorial(u);
  
        r[0] = u.x; r[4] = u.y; r[ 8] = u.z; r[12] = -(vistaX * u.x + vistaY * u.y + vistaZ * u.z); 
        r[1] = v.x; r[5] = v.y; r[ 9] = v.z; r[13] = -(vistaX * v.x + vistaY * v.y + vistaZ * v.z);
        r[2] = n.x; r[6] = n.y; r[10] = n.z; r[14] = -(vistaX * n.x + vistaY * n.y + vistaZ * n.z);
        r[3] =   0; r[7] =   0; r[11] =   0; r[15] = 						   1;
      }

      /* Multiplicación de matrices de 4 x 4, c = a * b */
      function multiplica(c, a, b) {
        let r = new Array(16);
        let i, j, k;
        for (i = 0; i < 4; i++){
          for (j = 0; j < 4; j++){
            let s = 0;
            for (k = 0; k < 4; k++)
              s = s + a[i + k * 4] * b[k + j * 4];
              r[i + j * 4] = s;
            }
          }
        for (i = 0; i < 16; i++)
          c[i] = r[i];
      }

      /* Multiplicación de matriz 4 x 4 * vector 3, c = a * b */
      function multiplicaMV(c, a, b) {
        let r = new Array(16);

        /*
          | a[0] a[4] a[ 8] a[12] |     | b[0] |
          | a[1] a[5] a[ 9] a[13] |  *  | b[1] |
          | a[2] a[6] a[10] a[14] |     | b[2] |
          | a[3] a[7] a[11] a[15] |
          */

        r[0] = a[0] * b[0] + a[4] * b[1] + a[ 8] * b[2] + a[12];
        r[1] = a[1] * b[0] + a[5] * b[1] + a[ 9] * b[2] + a[13];
        r[2] = a[2] * b[0] + a[6] * b[1] + a[10] * b[2] + a[14];
        for (var i = 0; i < 3; i++)
          c[i] = r[i];
      }

      /* Transpuesta de una matriz 4 x 4 */
      function transpuesta(r, m) {
        var i = 0;
        for (var j = 0; j < 4; j++)
          for (var k = 0; k < 4; k++) {
            r[j + k * 4] = m[i];
            i++;
          }
      }

      /* Invierte una matriz de 4 x 4, b = inv(a) */
      /* Aquí está una versión eficiente, utilizando el 
        * Teorema de Expansión de Laplace (página 9) */
      function invierte(b, a) {

        /*
          | a[0] a[4] a[ 8] a[12] |
          | a[1] a[5] a[ 9] a[13] |
          | a[2] a[6] a[10] a[14] |
          | a[3] a[7] a[11] a[15] |
        */

        var s0 = a[0] * a[5] - a[1] * a[4];
        var s1 = a[0] * a[9] - a[1] * a[8];
        var s2 = a[0] * a[13] - a[1] * a[12];
        var s3 = a[4] * a[9] - a[5] * a[8];
        var s4 = a[4] * a[13] - a[5] * a[12];
        var s5 = a[8] * a[13] - a[9] * a[12];

        var c5 = a[10] * a[15] - a[11] * a[14];
        var c4 = a[6] * a[15] - a[7] * a[14];
        var c3 = a[6] * a[11] - a[7] * a[10];
        var c2 = a[2] * a[15] - a[3] * a[14];
        var c1 = a[2] * a[11] - a[3] * a[10];
        var c0 = a[2] * a[7] - a[3] * a[6];

        // Se deberia verificar por el determinante igual a 0
        var invdet = 1.0 / (s0 * c5 - s1 * c4 + s2 * c3 + s3 * c2 - s4 * c1 + s5 * c0);

        b[0] = ( a[5] * c5 - a[9] * c4 + a[13] * c3) * invdet;
        b[4] = (-a[4] * c5 + a[8] * c4 - a[12] * c3) * invdet;
        b[8] = ( a[7] * s5 - a[11] * s4 + a[15] * s3) * invdet;
        b[12] = (-a[6] * s5 + a[10] * s4 - a[14] * s3) * invdet;

        b[1] = (-a[1] * c5 + a[9] * c2 - a[13] * c1) * invdet;
        b[5] = ( a[0] * c5 - a[8] * c2 + a[12] * c1) * invdet;
        b[9] = (-a[3] * s5 + a[11] * s2 - a[15] * s1) * invdet;
        b[13] = ( a[2] * s5 - a[10] * s2 + a[14] * s1) * invdet;

        b[2] = ( a[1] * c4 - a[5] * c2 + a[13] * c0) * invdet;
        b[6] = (-a[0] * c4 + a[4] * c2 - a[12] * c0) * invdet;
        b[10] = ( a[3] * s4 - a[7] * s2 + a[15] * s0) * invdet;
        b[14] = (-a[2] * s4 + a[6] * s2 - a[14] * s0) * invdet;

        b[3] = (-a[1] * c3 + a[5] * c1 - a[9] * c0) * invdet;
        b[7] = ( a[0] * c3 - a[4] * c1 + a[8] * c0) * invdet;
        b[11] = (-a[3] * s3 + a[7] * s1 - a[11] * s0) * invdet;
        b[15] = ( a[2] * s3 - a[6] * s1 + a[10] * s0) * invdet;

      }

      /***************************************************************************/
      /* Paso 3: Se define la geometría y se almacenan en los buffers de memoria.*/
      /* Paso 4: Se renderizan los objetos                                       */
      /***************************************************************************/

      /***************************************************************************/
      /* La Clase Grupo                                                          */
      /***************************************************************************/

      class Grupo {

        constructor() {
          this.nombre = "si_falta"; /* Nombre del grupo */
          this.triangulos = new Array();     /* Arreglo de índice de triangulos */
          this.material = 0;        /* Indice del color del material del grupo */
        }

        setNombre(nombre) {
          this.nombre = nombre;
        }

        getNombre() {
          return this.nombre;
        }

        adiTriangulo(t) {
          this.triangulos.push(t);
        }

        getTriangulo(indice){
          return this.triangulos[indice];
        }

        getNumTriangulos(){
          return this.triangulos.length;
        }

        setMaterial(material){
          this.material = material;
        }

        getMaterial() {
          return this.material;
        }

        toString() {
          return this.nombre + 
            "<br> triangulos: " + this.triangulos +
            "<br> material  : " + this.material;
        }
      }


      /***************************************************************************/
      /* La Clase Material                                                       */
      /***************************************************************************/

      class Material {
        constructor() {
          this.ambiente = new Array(3);  /* Arreglo del color ambiente */
          this.difuso = new Array(3);    /* Arreglo del color difuso */
          this.especular = new Array(3); /* Arreglo del color especular */
          this.nombre = "si_falta";             /* Nombre del material */
          this.brillo = 0;                      /* Exponente del brillo */
          this.ambiente[0] = 0.2;
          this.ambiente[1] = 0.2;
          this.ambiente[2] = 0.2;
          this.difuso[0] = 0.8;
          this.difuso[1] = 0.8;
          this.difuso[2] = 0.8;
          this.especular[0] = 0.0;
          this.especular[1] = 0.0;
          this.especular[2] = 0.0;
        }

        inicializa(nombre, ambiente, difuso, especular, brillo) {
          this.nombre = nombre;
          this.ambiente = ambiente;
          this.difuso = difuso;
          this.especular = especular;
          this.brillo = brillo;
        }
  
        setNombre(nombre) {
          this.nombre = nombre;
        }

        setAmbiente(ambiente) {
          this.ambiente = ambiente;
        }

        setDifuso(difuso) {
          this.difuso = difuso;
        }

        setEspecular(especular) {
          this.especular = especular;
        }

        setBrillo(brillo) {
          this.brillo = brillo;
        }

        getNombre() {
          return this.nombre;
        }

        getAmbiente() {
          return this.ambiente;
        }

        getDifuso() {
          return this.difuso;
        }

        getEspecular() {
          return this.especular;
        }

        getBrillo() {
          return this.brillo;
        }

        toString() {
          return this.nombre + 
            "<br> Ka: " + this.ambiente +
            "<br> Kd: " + this.difuso +
            "<br> Ks: " + this.especular +
            "<br> Ns: " + this.brillo;
        }
}

      /***************************************************************************/
      /* La Clase ProcesaCadena                                                  */
      /***************************************************************************/

      class ProcesaCadena {

        inicia(cadena) {
          this.cadena = cadena;
          this.indice = 0;
        }

        esDelimitador(c) {
          return (
            c == ' ' ||
            c == '\t' ||
            c == '(' ||
            c == ')' ||
            c == '"' ||
            c == "'"
          );
        }

        saltaDelimitadores() {
          while (this.indice < this.cadena.length && 
                    this.esDelimitador(this.cadena.charAt(this.indice))) {
            this.indice++;
          }
        };

        obtLongPalabra(inicio) {
          var i = inicio;
          while (i < this.cadena.length &&
                  !this.esDelimitador(this.cadena.charAt(i))) {
                i++;
          }
          return i - inicio;
        };

        getToken() {
          var n, subcadena;
          this.saltaDelimitadores();
          n = this.obtLongPalabra(this.indice);
          if (n === 0) {
            return null;
          }
          subcadena = this.cadena.substr(this.indice, n);
          this.indice = this.indice + (n + 1);
          return subcadena.trim();
        }

        getInt() {
          var token = this.getToken();
          if (token) {
            return parseInt(token, 10);
          }
          return null;
        }

        getFloat() {
          var token = this.getToken();
          if (token) {
            return parseFloat(token);
          }
          return null;
        }
      }

      /***************************************************************************/
      /* La Clase Objeto                                                         */
      /***************************************************************************/

      class Objeto {
        constructor(gl, ruta, nombreArchivo) {
          var x, y, z, token, lineas, numVertices,numNormales, numTriangulos;
          var minX, maxX, minY, maxY, minZ, maxZ, indiceDeGrupo;

          /* Arreglo de los colores de los Materiales */
          this.materiales = [];

          /* Arreglo de Grupos */
          this.grupos = [];

          /* Indices */
          this.indices = [];

          /* Las coordenadas cartesianas (x, y, z) */
          var vertices = [];

          /* Las normales x c/cara (x,y,z) */
          var normales = [];
          var normales_prev = [];

          /* Número de Vértices */
          numVertices = 0;

          /* Número de Normales */
          numNormales = 0;

          /* Número de Triangulos */
          numTriangulos = 0;

          // Agrega un grupo
          this.grupos.push(new Grupo());
          indiceDeGrupo = 0;

          /* Lee el archivo .obj */
          var datos_obj = this.lee_archivo_obj(ruta + nombreArchivo);

          /* Divide por lineas */
          lineas = datos_obj.split("\n");

          // Crea ProcesaCadena
          var pc = new ProcesaCadena();

          minX = Number.MAX_VALUE; maxX = Number.MIN_VALUE;
          minY = Number.MAX_VALUE; maxY = Number.MIN_VALUE;
          minZ = Number.MAX_VALUE; maxZ = Number.MIN_VALUE;

          for (var i = 0; i < lineas.length; i++) {
            pc.inicia(lineas[i]);
            token = pc.getToken();
            if (token != null) {
              switch(token) {
                case 'mtllib': /* nombre del arch. de materiales */
                  var nombre_archivo_material = pc.getToken();

                  /* Lee los datos del archivo .mtl */
                  this.lee_datos_archivo_mtl(ruta + nombre_archivo_material);
                  
                  break;
                case 'v': /* vértice */
                  x = pc.getFloat();
                  y = pc.getFloat();
                  z = pc.getFloat();
                  vertices.push(x);
                  vertices.push(y);
                  vertices.push(z);
                  numVertices++;

                  minX = Math.min(minX, x); maxX = Math.max(maxX, x);
                  minY = Math.min(minY, y); maxY = Math.max(maxY, y);
                  minZ = Math.min(minZ, z); maxZ = Math.max(maxZ, z);

                  /* Inicializa la normal de cada vértice */
                  normales_prev.push(new Vector3(0,0,0));
                  numNormales++;

                  break;
                case 'f': /* cara */
                  this.indices.push(pc.getInt()-1);
                  this.indices.push(pc.getInt()-1);
                  this.indices.push(pc.getInt()-1);
                  this.grupos[indiceDeGrupo].adiTriangulo(numTriangulos);
                  numTriangulos++;
                  var tokenEntero = pc.getInt();
                  while (tokenEntero != null) {
                    var k = this.indices.length;
                    this.indices.push(this.indices[k - 3]);    // v0
                    this.indices.push(this.indices[k - 1]);    // v2
                    this.indices.push(tokenEntero-1); // v3
                    this.grupos[indiceDeGrupo].adiTriangulo(numTriangulos);
                    numTriangulos++;
                    tokenEntero = pc.getInt();
                  }
                  break;
                case 'g':
                case 'group': /* nombre de grupo */
                  var nombre = pc.getToken();
                  if (nombre != null){
                    indiceDeGrupo = this.buscaGrupo(nombre);
                    if (indiceDeGrupo == -1){
                      var g = new Grupo();
                      g.setNombre(nombre);
                      this.grupos.push(g);
                      indiceDeGrupo = this.grupos.length - 1;
                    }
                  }
                  break;
                case 'usemtl': /* nombre de material */
                  var nombre = pc.getToken();
                  var indiceDeMaterial = this.buscaMaterial(nombre);
                  this.grupos[indiceDeGrupo].setMaterial(indiceDeMaterial);
                  break;
              }
            }
          }

          /* Redimensiona las coordenadas entre [-1,1] */
          var tam_max = 0, escala;
          tam_max = Math.max(tam_max, maxX-minX);
          tam_max = Math.max(tam_max, maxY-minY);
          tam_max = Math.max(tam_max, maxZ-minZ);
          escala = 2.0 / tam_max;

          /* Actualiza los vértices */
          for (var i = 0; i < numVertices * 3; i += 3) {
            vertices[i  ] = escala * (vertices[i  ] - minX) - 1.0;
            vertices[i+1] = escala * (vertices[i+1] - minY) - 1.0;
            vertices[i+2] = escala * (vertices[i+2] - minZ) - 1.0;
          }

          /* Lee las caras y obtiene las normales de los vértices */
          var v1 = new Vector3(0,0,0); // v1
          var v2 = new Vector3(0,0,0); // v2
          var v3 = new Vector3(0,0,0); // v3
          var normalCara = new Vector3(0,0,0);  // normal
          var a, b, c, a1, b1, c1;

          for (var i = 0; i < numTriangulos * 3; i+=3){
            a = this.indices[i  ];
            b = this.indices[i+1];
            c = this.indices[i+2];

            a1 = a * 3; // Obtiene la posición del primer vértice
            v1.x = vertices[a1 + 0]; // v1
            v1.y = vertices[a1 + 1];
            v1.z = vertices[a1 + 2];

            b1 = b * 3; // Obtiene la posición del segundo vértice
            v2.x = vertices[b1 + 0]; // v2
            v2.y = vertices[b1 + 1];
            v2.z = vertices[b1 + 2];

            c1 = c * 3; // Obtiene la posición del tercer vértice
            v3.x = vertices[c1 + 0]; // v3
            v3.y = vertices[c1 + 1];
            v3.z = vertices[c1 + 2];

            /* Obtiene la normal de la cara */
            normalCara = normalCara.normal(v1, v2, v3);
    
            /* Suma la normal de la cara, a la normal de cada vértice */
            normales_prev[a] = normalCara.mas(normales_prev[a]); // normal del vértice a
            normales_prev[b] = normalCara.mas(normales_prev[b]); // normal del vértice b
            normales_prev[c] = normalCara.mas(normales_prev[c]); // normal del vértice c
          }

          /* Lee las normales de los vértices */
          for (var i = 0; i < numNormales; i++) {

            /* Normaliza la normal de cada vértice */
            normales_prev[i].normaliza();
      
            normales.push(normales_prev[i].x);
            normales.push(normales_prev[i].y);
            normales.push(normales_prev[i].z);

          }

          var verticeBuffer = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, verticeBuffer);
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
          gl.enableVertexAttribArray(0);
          gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);

          var normalBuffer = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normales), gl.STATIC_DRAW);
          gl.enableVertexAttribArray(1);
          gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 0, 0);

          gl.bindBuffer(gl.ARRAY_BUFFER, null);

          /* Se genera un nombre (código) para el buffer */ 
          this.indiceBuffer = gl.createBuffer();

        }

        dibuja(gl) {

          var ambiente, difuso, especular, brillo, indice, numTriangulos, i;

          i = 0;

          while (i < this.grupos.length) {

            /* Obtiene el número de triángulos del grupo */
            numTriangulos = this.grupos[i].getNumTriangulos();

            if (numTriangulos == 0) {
              i++;
              continue;
            }

            /* Obtiene el indice del material */
            indice = this.grupos[i].getMaterial();

            ambiente = this.materiales[indice].getAmbiente();
            difuso = this.materiales[indice].getDifuso();
            especular = this.materiales[indice].getEspecular();
            brillo = this.materiales[indice].getBrillo();

            /* Se envia el Material al shader de fragmento */
            gl.uniform3f(u_ka, ambiente[0], ambiente[1], ambiente[2]);
            gl.uniform3f(u_kd, difuso[0], difuso[1], difuso[2]);
            gl.uniform3f(u_ks, especular[0], especular[1], especular[2]);
            gl.uniform1f(u_brillo, brillo);

            /* Se habilita el arreglo de los vértices (indice = 0) */
            gl.enableVertexAttribArray(0);

            /* Se habilita el arreglo de las normales (indice = 1) */
            gl.enableVertexAttribArray(1);

            var _indices = [];

            /* Lee los indices */
            for (var j = 0; j < numTriangulos; j++) {
              let _indice = this.grupos[i].getTriangulo(j);
              _indices.push(this.indices[_indice * 3 + 0]);
              _indices.push(this.indices[_indice * 3 + 1]);
              _indices.push(this.indices[_indice * 3 + 2]);
            }

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indiceBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(_indices), gl.STATIC_DRAW);
            gl.drawElements(gl.TRIANGLES, numTriangulos * 3, gl.UNSIGNED_SHORT, 0);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

            i++;

          }
          
        }

        /* Lee el archivo OBJ */
        lee_archivo_obj(nombreArchivo){
          var byteArray = [];
          var request = new XMLHttpRequest();
          request.onreadystatechange = function () {
            if (request.readyState === 4 && request.status !== 404) {
              byteArray = request.responseText
            }
          }
          request.open('GET', nombreArchivo, false); // Crea una solicitud para abrir el archivo
          request.send(null);                        // Enviando la solicitud
          return byteArray;
        }

        /* Lee el archivo MTL */
        lee_archivo_mtl(nombreArchivo){
          var byteArray = [];
          var request = new XMLHttpRequest();
          request.onreadystatechange = function () {
            if (request.readyState === 4 && request.status !== 404) {
              byteArray = request.responseText
            }
          }
          request.open('GET', nombreArchivo, false); // Crea una solicitud para abrir el archivo
          request.send(null);                        // Enviando la solicitud
          return byteArray;
        }

        /* Lee los datos de un archivo .MTL (archivo de los colores de los materiales) */
        lee_datos_archivo_mtl(nombreArchivo) {

          /* Lee el archivo .mtl */
          var datos_mtl = this.lee_archivo_mtl(nombreArchivo);

          /* Divide por lineas */
          var lineas = datos_mtl.split('\n');

          lineas.push(null);  // Adiciona null

          var indice = 0;

          var linea;

          // Crea ProcesaCadena
          var pc = new ProcesaCadena();

          while ((linea = lineas[indice++]) != null) {
            pc.inicia(linea);
            var token = pc.getToken();
            if(token == null)	 continue;

            switch(token){
              case '#':
                continue;
              case 'newmtl':  /* nombre del material */
                var nombre = pc.getToken();
                this.materiales.push(new Material());
                this.materiales[this.materiales.length-1].setNombre(nombre);
                break;
              case 'Ka':      /* ambiente */
                var ambiente = new Array(3);
                ambiente[0] = pc.getFloat();
                ambiente[1] = pc.getFloat();
                ambiente[2] = pc.getFloat();
                this.materiales[this.materiales.length-1].setAmbiente(ambiente);
                break;
              case 'Kd':      /* difuso */
                var difuso = new Array(3);
                difuso[0] = pc.getFloat();
                difuso[1] = pc.getFloat();
                difuso[2] = pc.getFloat();
                this.materiales[this.materiales.length-1].setDifuso(difuso);
                break;
              case 'Ks':      /* especular */
                var especular = new Array(3);
                especular[0] = pc.getFloat();
                especular[1] = pc.getFloat();
                especular[2] = pc.getFloat();
                this.materiales[this.materiales.length-1].setEspecular(especular);
                break;
              case 'Ns':      /* brillo */
                var brillo = pc.getFloat();
                this.materiales[this.materiales.length-1].setBrillo(brillo);
                break;
            }
          }
        }

        /* Busca el grupo */
        buscaGrupo(nombre) {
          for (var i = 0; i < this.grupos.length; i++)
            if (nombre == this.grupos[i].getNombre())
              return i;
          return -1;
        }

        /* Busca el Material */
        buscaMaterial(nombre) {
          for (var i = 0; i < this.materiales.length; i++)
            if (nombre == this.materiales[i].getNombre())
              return i;
          return -1;
        }
      }

      /***************************************************************************/
      /* Eventos del Ratón                                                       */
      /***************************************************************************/

      function mouseDown(event) {
        var posx = new Number();
        var posy = new Number();

        /* Obtiene la coordenada dentro de la área mayor */
        if (event.x != undefined && event.y != undefined) {
          posx = event.x;
          posy = event.y;
        } else {
          posx = event.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
          posy = event.clientY + document.body.scrollTop + document.documentElement.scrollTop;
        }

        /* Obtiene la coordenada dentro del canvas */
        posx = posx - canvas.offsetLeft;
        posy = posy - canvas.offsetTop;

        antX = posx;
        antY = posy;

        boton_izq_presionado = true;

        return false;
      };

      function mouseUp(e){
        boton_izq_presionado = false;
      };

      function mouseMove(event) {

        if (!boton_izq_presionado)
          return false;

        var posx = new Number();
        var posy = new Number();

        /* Obtiene la coordenada dentro de la área mayor */
        if (event.x != undefined && event.y != undefined) {
          posx = event.x;
          posy = event.y;
        } else {
          posx = event.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
          posy = event.clientY + document.body.scrollTop + document.documentElement.scrollTop;
        }

        /* Obtiene la coordenada dentro del canvas */
        posx = posx - canvas.offsetLeft;
        posy = posy - canvas.offsetTop;

        var dx = posx - antX;
        var dy = posy - antY;

        rotX = rotX + dx * 0.36; // 180 / 500 = 0.36
        rotY = rotY + dy * 0.36;

        antX = posx;
        antY = posy;

      };

      function dibuja() {
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        /* Matriz del Modelo */
        identidad(MatrizModelo);
        traslacion(MatrizModelo, 0, 0, -5);        
        rotacionY(MatrizModelo, rotX);
        rotacionX(MatrizModelo, rotY);
        gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);

        /* Renderiza */
        objeto.dibuja(gl);

        /* Solicita que el navegador llame nuevamente a dibuja */
        requestAnimationFrame(dibuja);
      }

      /***************************************************************************/
      /* Paso 5: Se prepara el lienzo y se obtiene el contexto del WebGL.        */
      /***************************************************************************/

      function elije_objeto(){

        rotX = rotY = 0;

        var ruta = "Modelos/";
        var numeroObjeto = Number(document.getElementById("objeto").value);

        /* Se crean los objetos */
        switch(numeroObjeto) {
          case 0:
            objeto = new Objeto(gl, ruta, "cubo2.obj");
            break;
          case 1:
            objeto = new Objeto(gl, ruta, "f-16.obj");
            break;
          case 2:
            objeto = new Objeto(gl, ruta, "al.obj");
            break;
          case 3:
            objeto = new Objeto(gl, ruta, "porsche.obj");
            break;
          case 4:
            objeto = new Objeto(gl, ruta, "rose+vase.obj");
            break;
        };

        dibuja();

      }

      function main() {
        canvas = document.getElementById("webglcanvas");
        gl = canvas.getContext("webgl2");
        canvas.width = window.innerWidth;   // devuelve el ancho de la ventana 
        canvas.height = window.innerHeight; // devuelve el alto de la ventana           
        if (!gl) {
            document.write("WebGL 2.0 no está disponible en tu navegador");
            return;
        }
        canvas.addEventListener("mousedown", mouseDown, false);
        canvas.addEventListener("mouseup", mouseUp, false);
        canvas.addEventListener("mouseout", mouseUp, false);
        canvas.addEventListener("mousemove", mouseMove, false);
        document.getElementById("objeto").value = "0";
        document.getElementById("objeto").onchange = elije_objeto;
        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
        compilaEnlazaLosShaders();

        gl.useProgram(programaID);
        uMatrizProyeccion = gl.getUniformLocation(programaID, "uMatrizProyeccion");
        uMatrizVista = gl.getUniformLocation(programaID, "uMatrizVista");
        uMatrizModelo = gl.getUniformLocation(programaID, "uMatrizModelo");
        uPosicionVista = gl.getUniformLocation(programaID, "uPosicionVista");
        uPosicionLuz = gl.getUniformLocation(programaID, "uPosicionLuz");
        u_Ia = gl.getUniformLocation(programaID, "u_Ia");
        u_Id = gl.getUniformLocation(programaID, "u_Id");
        u_Is = gl.getUniformLocation(programaID, "u_Is");
        u_ka = gl.getUniformLocation(programaID, "u_ka");
        u_kd = gl.getUniformLocation(programaID, "u_kd");
        u_ks = gl.getUniformLocation(programaID, "u_ks");
        u_brillo = gl.getUniformLocation(programaID, "u_brillo");

        /* Matriz de Proyección */
        perspective(MatrizProyeccion, 60, gl.canvas.width/gl.canvas.height, 1, 100);
        gl.uniformMatrix4fv(uMatrizProyeccion, false, MatrizProyeccion);

        /* Matriz de la Cámara o de la Vista */
        lookAt(MatrizVista, posicionVista[0], posicionVista[1], posicionVista[2], 0, 0, -1, 0, 1, 0);
        gl.uniformMatrix4fv(uMatrizVista, false, MatrizVista);

        /* Posición de la vista */
        gl.uniform3fv(uPosicionVista, posicionVista);

        /* Posición de la luz */
        var pLuz = new Array(3);
        multiplicaMV(pLuz, MatrizVista, posicionLuz);
        gl.uniform3fv(uPosicionLuz, pLuz);          

        gl.enable(gl.DEPTH_TEST);
        gl.clearColor(0.0, 0.0, 0.0, 1.0);

        /* Se envia la Iluminación al shader de fragmento */
        gl.uniform3f(u_Ia, 0.2, 0.2, 0.2);
        gl.uniform3f(u_Id, 1.0, 1.0, 1.0);
        gl.uniform3f(u_Is, 1.0, 1.0, 1.0);

        elije_objeto();
      }
      window.onload = main;
    </script>
  </body>
</html>